#!/usr/bin/perl -w

my $sleep;
BEGIN {
    $sleep = $ENV{ADB_FAKE_SLEEP} || 0;
    if ($sleep < 0) {
        # Do this as early as possible in the hope that TERM won't arrive
        # before we set the signal handler
        $SIG{TERM} = "IGNORE";
        $sleep = -$sleep;
    }
}

use strict;
use warnings;

our $VERSION = "1.000";

use FindBin qw($Script);
our $Bin;

# If the program runs as /foobar/bin/program, find libraries in /foobar/lib
BEGIN {
    # Even on windows FindBin uses / in the reported path
    $Bin = $FindBin::Bin;
    $Bin =~ s{/+\z}{};
    $Bin =~
        ($^O eq "MSWin32" ?
         qr{^((?:[A-Z]:)?(?:/[a-zA-Z0-9_:.~ -]+)*)/[a-zA-Z0-9_.-]+/*\z} :
         qr{^((?:/[a-zA-Z0-9_:.-]+)*)/[a-zA-Z0-9_.-]+/*\z}) ||
         die "Could not parse bin directory '$Bin'";
    # Use untainted version of lib
    require lib;
    # Support a simple --blib option for pre-install testing
    "lib"->import(@ARGV && $ARGV[0] eq "--blib" ? shift && "$1/blib/lib" : "$1/lib");
}

use IO::Socket qw(IPPROTO_TCP TCP_NODELAY);
use IO::Socket::IP qw();
use Scalar::Util qw(weaken refaddr);
use Getopt::Long 2.24 qw(:config bundling);
use POSIX qw(_exit);
use Errno qw(EAGAIN EINTR EWOULDBLOCK);

use ADB::Client::Events qw(mainloop timer event_init);
use ADB::Client::Utils qw(display_string ip_port_from_addr IPV6);

use constant {
    CONTROL	=> 0,	# Control port
    LISTENER	=> 1,	# Normal fake adb server
    UNACCEPTABLE=> 2,	# Doesnt' even accept connections (OS will accept)
    UNREACHABLE	=> 3,	# Occupies a port but refuses connection (no listen)
    BLACKHOLE	=> 4,	# Eats everything on the accepted connection. Can talk
    CLOSER	=> 5,	# Closes the connection as soon as n bytes are sent
    ECHO	=> 6,	# Echoes whatever you type

    NULL	=> "/dev/null",
};

my $IDLE_TIMEOUT = 10;

$| = 1;

my $Listen = "tcp:localhost:5037";
my @argv_old = @ARGV;
die "Could not parse your command line. Try $0 -h\n" unless
    GetOptions("a!"		=> \my $all,
               "L=s"		=> \$Listen,
               "reply-fd=o"	=> \my $reply_fd,
               "acceptfd=o"	=> \my $accept_fd,
               # Non standard options
               "timeout|t=o"	=> \$IDLE_TIMEOUT,
           );

# Little set of model devices
my %devices = (
    "10.253.0.13:5555" => [
        "device",
        "product:zerofltexx model:SM_G920F device:zeroflte",
        [qw(fixed_push_mkdir shell_v2 apex stat_v2 abb fixed_push_symlink_timestamp cmd abb_exec)]],
    "52000c4748d6a283" => [
        "device",
        "usb:1-1.2 product:lineage_kminilte model:SM_G800F device:kminiltexx",
        [qw(shell_v2 cmd stat_v2)]],
);

# Make sure we will quit by ourselves after inactivity so testing won't get
# stuck in case of errors in adb_fake
my $accepted = my $listening = my $devices = 0;
my ($finish, $idle_timeout, %listeners, %specials, @sockets);

our $BLOCK_SIZE = 65536;
# Default ADB version for plain adb_fake
our $ADB_VERSION = 39;
# Default ADB version for adb_fake with arguments (called like real adb)
our $ADB_VERSION2 = 30;
our $TIMEOUT	= 2;

sub acceptable {
    my ($listener) = @_;

    my $addr = accept(my $socket, $listener->{socket});
    if (!$addr) {
        return if $! == EAGAIN || $! == EINTR || $! == EWOULDBLOCK;
        die "Accept error: $^E";
    }
    unidle();
    $socket->blocking(0);
    setsockopt($socket, IPPROTO_TCP, TCP_NODELAY, 1) ||
        die("Could not set TCP_NODELAY on accepted socket: $^E");
    my $class = $listener->{type} == CONTROL ? "Control" : "ADB";
    my $state = $class->new($socket, $listener->{type});
    ++$accepted;
    weaken($state->{listener} = $listener);
    $listener->{accepted}{$state->{key}} = $state;
    weaken(my $s = $state);
    $socket->add_read(sub { $s->reader });
    $state->output($listener->{arg}) if
        $listener->{type} == BLACKHOLE && $listener->{arg} ne "";
    $state->output("adb_fake $VERSION\n") if $listener->{type} == CONTROL;
    $state->adb_close if $listener->{type} == CLOSER && $listener->{arg} <= 0;
}

sub add_listener {
    my ($type, $arg, $host, $port) = @_;
    $type = shift // LISTENER;

    $host ||= "127.0.0.1";
    $port ||= 0;
    my $socket = defined fileno $port ? $port :
        IO::Socket::IP->new(
            $type == UNREACHABLE ? () : (Listen => 5),
            V6Only	=> 0,
            ReuseAddr	=> 1,
            LocalHost	=> $host,
            LocalPort	=> $port) ||
            die "Could not create listening socket $host:$port: $^E";
    # Workaroud for bind bug in IO::Socket::IP
    # (failing bind does not lead to fatal error, seen in verson 0.39)
    # And we want to set blocking 0 for acceptfd anyways
    $socket->blocking(0);
    my $addr = getsockname($socket) || die "Could not getsockname: $^E";
    $port = (ip_port_from_addr($addr))[1];
    my $key = refaddr($socket);
    my $listener = bless {
        key		=> $key,
        socket		=> $socket,
        port		=> $port,
        accepted	=> {},
        trackers	=> {},
        type		=> $type,
        arg		=> $arg,
        $type == LISTENER ? (version => $arg // $ADB_VERSION) : (),
    }, "Listener";
    ++$listening;
    if ($type == LISTENER) {
        $listeners{$key} = $listener;
        $listener->{root} = 0;
        $listener->{devices} = Devices->init;
    } else {
        $specials{$key} = $listener;
    }
    if ($type != UNACCEPTABLE && $type != UNREACHABLE) {
        weaken(my $l = $listener);
        $socket->add_read(sub { acceptable($l) });
    }
    return $listener->{port};
}

sub finish {
    $finish = 1;
    $idle_timeout = undef;
    %specials = ();
    %listeners = ();
}

sub unidle {
    $idle_timeout = timer($IDLE_TIMEOUT, \&finish);
}

my $sleeper;
sub daemon {
    $reply_fd //
        die "reply fd for adb server to client communication not specified.\n";
    $reply_fd =~ /^\d+\z/a ||
        die "reply_fd '$reply_fd' is not a natural number\n";
    open(my $reply, ">&=", $reply_fd) ||
        die "Could not fdopen $reply_fd: $^E\n";
    $reply->autoflush(1);

    open(STDOUT, ">", NULL) ||
        die "Could not open '" . NULL . "' as STDOUT: $^E";
    open(STDIN, "<", NULL) ||
        die "Could not open '" . NULL . "' as STDIN: $^E";

    if (my $log_path = $ENV{ANDROID_ADB_LOG_PATH} // NULL) {
        open(my $fh, ">", $log_path) || die "open($log_path): $^E\n";
        open(STDERR, ">&", $fh) || die "Cannot dup to STDERR: $^E";
        close($fh) || die "Could not close($log_path): $^E";
    }
    STDERR->autoflush(1);

    # Simulate an error
    my $err = $ENV{ADB_FAKE_ERROR};
    die $err if $err;

    my $port;
    if (my ($host, $p) = $Listen =~ m{^tcp:(?:(.*):)?(\d+)\z}a) {
        $host //= "localhost";
        $host eq "localhost" ||
            die "error: could not install *smartsocket* listener: listening on specified hostname currently unsupported (@argv_old)\n";
        $port = $p;
    } elsif (my ($fd) = $Listen =~ m{^acceptfd:(\d+)\z}a) {
        open($port, "<&=", $fd) || die "Could not fdopen $fd: $^E";
    } else {
        die "error: could not install *smartsocket* listener: unknown socket specification '$Listen'\n";
    }

    my $ip =
        !$all ? "127.0.0.1" :
        IPV6 ? "::" :
        "0.0.0.0";
    $sleeper = timer($sleep, sub {
        add_listener(LISTENER, $ADB_VERSION2, $ip, $port);
        print($reply "OK\n") || die "Could not write to fd $reply_fd: $^E";
        close($reply) || die "Could not close fd $reply_fd: $^E";
    });
    mainloop();
}

sub main {
    if (@ARGV) {
        daemon();
    } else {
        my $port = add_listener(CONTROL);
        print("Port: $port\n") || die "print: $^E";
        mainloop();
        print("Close: $listening $accepted $devices\n") || die "print: $^E";
    }
}

package Accepted;
use Scalar::Util qw(weaken);
use Errno qw(ECONNRESET EAGAIN EINTR EWOULDBLOCK);
use Data::Dumper;

use ADB::Client::Events qw(timer);

sub reader {
    my ($state) = @_;

    my $rc = sysread($state->{socket}, my $buffer, $BLOCK_SIZE);
    if ($rc) {
        ::unidle();
        $state->{in} .= $buffer;
        eval {
            $state->{on_read}->($state, $rc);
        };
        $state->{on_error}->($state, $@) if $@;
        return $rc;
    }
    if (defined $rc || $! == ECONNRESET) {
        ::unidle();
        # EOF
        $state->{on_close}->($state, defined $rc ? 0 : $!);
        return;
    }
    return if $! == EAGAIN || $! == EINTR || $! == EWOULDBLOCK;
    ::unidle();
    die "Read error: $^E";
}

sub writer {
    my ($state) = @_;

    my $rc = syswrite($state->{socket}, $state->{out}, $BLOCK_SIZE);
    if ($rc) {
        ::unidle();
        substr($state->{out}, 0, $rc, "");
        if ($state->{out} eq "") {
            $state->{socket}->delete_write();
            $state->{timeout} = undef;
        }
        if (my $written = delete $state->{written}) {
            weaken($state);
            $written->($state);
        }
        return;
    }
    # Dunno how to handle this.
    # Is it even possible ? Never found an answer
    die "Assertion: Length 0 write" if defined $rc;
    return if $! == EAGAIN || $! == EINTR || $! == EWOULDBLOCK;
    ::unidle();
    die "Write error: $^E";
}

sub output {
    my $state = shift;

    return if $state->{written};

    my $str = join("", @_);
    return if $str eq "";
    # Should always be downgraded, but let's be paranoid
    die "Unexpected upgrade string" if utf8::is_utf8($str);

    if ($state->{out} eq "") {
        weaken(my $s = $state);
        $state->{socket}->add_write(sub { $s->writer });
        $state->{timeout} = timer($state->{write_timeout}, sub { $s->{on_error}->($s, "Write timed out") });
    }
    $state->{out} .= $str;
}

sub DESTROY {
    # print STDERR "DESTROY(@_)\n";
    my ($state) = @_;

    # Rescue sockets so they will get closed by the final _exit
    push @sockets, $state->{socket} if $finish;
    $state->{socket}->delete_write if $state->{out} ne "";
    $state->{socket}->delete_read;
    $state->{timeout} = undef;

    --$accepted;
}

sub dumper {
    my ($accepted, $msg) = @_;

    local $Data::Dumper::Indent	  = 1;
    local $Data::Dumper::Sortkeys = 1;
    local $Data::Dumper::Useqq	  = 1;
    local $Data::Dumper::Terse    = 1;

    local $accepted->{listener} = "<listener>";
    $msg ||= "Accepted";
    $accepted->output($msg . ": " . Dumper($accepted));
}

package Control;
use Scalar::Util qw(refaddr);

our @ISA = qw(Accepted);

sub new {
    my ($class, $socket) = @_;

    return bless {
        key		=> refaddr($socket),
        socket		=> $socket,
        in		=> "",
        out 		=> "",
        on_read		=> \&control_read,
        on_close	=> \&::finish,
        on_error	=> sub { die $_[1]},
        write_timeout	=> $TIMEOUT,
    }, $class;
}

sub control_read {
    my ($state) = @_;

    while ($state->{in} =~ s/^[^\S\n]*(.*?)[^\S\n]*\n//) {
        my $command = lc($1);
        my $port;
        if ($command =~ m{listener(?:\s+(\d+))?\z}) {
            $port = ::add_listener(::LISTENER, $1 // $ADB_VERSION);
        } elsif ($command =~ m{listener6(?:\s+(\d+))?\z}) {
            $port = ::add_listener(::LISTENER, $1 // $ADB_VERSION, "::1");
        } elsif ($command =~ m{listener0(?:\s+(\d+))?\z}) {
            $port = ::add_listener(::LISTENER, $1 // $ADB_VERSION, "::");
        } elsif ($command eq "unacceptable") {
            $port = ::add_listener(::UNACCEPTABLE);
        } elsif ($command eq "unacceptable6") {
            $port = ::add_listener(::UNACCEPTABLE, undef, "::1");
        } elsif ($command eq "unreachable") {
            $port = ::add_listener(::UNREACHABLE);
        } elsif ($command eq "unreachable6") {
            $port = ::add_listener(::UNREACHABLE, undef, "::1");
        } elsif ($command =~ m{^blackhole(?:\s(.*))?\z}) {
            my $arg = $1 // "";
            $arg =~ s/\\n/\n/g;
            $port = ::add_listener(::BLACKHOLE, $arg);
        } elsif ($command =~ m{closer(?:\s+(\d+))?\z}) {
            $port = ::add_listener(::CLOSER, $1 // 0);
        } elsif ($command eq "echo") {
            $port = ::add_listener(::ECHO);
        } elsif ($command eq "echo6") {
            $port = ::add_listener(::ECHO, undef, "::1");
        } elsif ($command eq "dump") {
            $state->dumper("State: ");
            return;
        } elsif ($command eq "quit") {
            ::finish();
            return;
        } elsif ($command eq "help") {
            $state->output("Valid commands (case insensitive):
Listener  [version]	Start a listener on 127.0.0.1
Listener6 [version]	Start a listener on ::1
Listener0 [version]	Start a listener on ::
Unacceptable		Start a listening port on 127.0.0.1 without accept handler
Unacceptable6		Start a listening port on ::1 without accept handler
Unreachable		Start a non-listening port on 127.0.0.1
Unreachable6		Start a non-listening port on 127.0.0.1
BlackHole [greeting]	Start a listener on 127.0.0.1 only reads
Closer [n]		Start a listener on 127.0.0.1 that closes after reading n bytes
Echo			Start a listener on 127.0.0.1 that echoes everything
Echo6			Start a listener on ::1 that echoes everything
Quit			Exit the program (not just the control connection)
Help			Show this help
Dump			Dump the current state
");
            return;
        } elsif ($command eq "") {
            return;
        } else {
            $state->output("Unknown: <$command>\n");
            return;
        }
        $state->output("Port: $port\n");
    }
}

package ADB;
use Scalar::Util qw(refaddr weaken);
use ADB::Client::Utils qw(callers);

use ADB::Client::Utils qw(display_string);

our @ISA = qw(Accepted);

use constant {
    FAIL	=> 0,
    OKAY	=> 1,
    UNCOUNTED	=> 2,
};

sub new {
    my ($class, $socket, $type) = @_;

    return bless {
        key		=> refaddr($socket),
        socket		=> $socket,
        in		=> "",
        out 		=> "",
        on_read		=>
        $type == ::LISTENER	? \&adb_read :
        $type == ::CLOSER	? \&adb_closer :
        $type == ::ECHO		? \&adb_echo :
        \&adb_discard,
        on_error	=> \&adb_error,
        on_close	=> \&adb_close,
        write_timeout	=> $TIMEOUT,

        transport	=> 0,
    }, $class;
}

sub adb_error {
    my ($state, $err) = @_;

    warn($err);
    $state->adb_close;
}

sub adb_close {
    my ($state) = @_;

    # print STDERR "ADB CLOSE ", callers();
    delete $state->{listener}{accepted}{$state->{key}};
    delete $state->{listener}{trackers}{$state->{key}};
}

sub adb_discard {
    my ($state, $rc) = @_;

    $state->{in} = "";
}

sub adb_closer {
    my ($state, $rc) = @_;

    $state->adb_close if length($state->{in}) >= $state->{listener}{arg};
}

sub adb_echo {
    my ($state, $rc) = @_;

    $state->output($state->{in});
    $state->{in} = "";
}

sub adb_read {
    my ($state, $rc) = @_;

    my $len = length $state->{in};
    while ($state->{in} ne "") {
        # For convenient debugging with telnet...
        next if $state->{in} =~ s/^[\r\n]+//;
        length $state->{in} >= 4 || return;
        my $code = substr($state->{in}, 0, 4);
        $code =~ /^[0-9a-fA-F]{4}\z/ ||
            die "Invalid length code: ", display_string($code);
        my $len = hex $code;
        length $state->{in} >= 4 + $len || return;
        my $command = substr($state->{in}, 0, 4 + $len, "");
        substr($command, 0, 4, "");
        $state->adb_command($command);
        if ($state->{on_read} != \&adb_read) {
            if ($state->{in} ne "") {
                $rc -= $len - length $state->{in};
                $state->{on_read}->($state, $rc);
            }
            last;
        }
    }
}

sub adb_output {
    my ($state, $status, $response, $keep_open) = @_;

    return if $state->{written};
    if (defined $status) {
        if ($status == UNCOUNTED) {
            $state->output("OKAY" . $response);
        } else {
            $state->output(
                ($status ? "OKAY" : "FAIL"),
                sprintf("%04X", length $response),
                $response);
            $state->{written} = \&adb_close;
        }
        $state->{written} = $keep_open && $status != FAIL ? undef : \&adb_close;
    } else {
        # Close after OKAY send (used by host:kill)
        $state->output("OKAY");
        weaken(my $listener = $state->{listener});
        $state->{written} = sub { $listener->close if $listener};
    }
}

sub transport_type_name {
    my ($type, $many) = @_;

    return $many ? "devices/emulators" : "device/emulator" if $type eq "any";
    return $many ? "devices/emulators" : "device/emulator" if $type eq "tcp";
    return $many ? "devices"           : "device"          if $type eq "usb";
    return $many ? "emulators"         : "emulator"        if $type eq "local";
    die "Unknown transport type '$type'";
}

sub adb_command {
    my ($state, $command) = @_;

    my $listener = $state->{listener};
    if ($command eq "host:version") {
        $state->adb_output(OKAY, sprintf("%04X", $listener->{version}));
    } elsif ($command eq "host:devices") {
        $state->adb_output(OKAY, $listener->{devices}->string);
    } elsif ($command eq "host:devices-l") {
        $state->adb_output(OKAY, $listener->{devices}->string_long);
    } elsif ($command eq "host:track-devices") {
        $state->adb_output(OKAY, $listener->{devices}->string, 1);
        # Become a tracker
        $listener->{trackers}{$state->{key}} = $state;
        $state->{on_read} = \&adb_close;
    } elsif ($command eq "host:features") {
        my $type = "any";
        my @devices = $state->{transport} ||
            $listener->{devices}->transport($type);
        if (@devices == 1) {
            $state->adb_output(OKAY, $devices[0]->features_string);
        } elsif (@devices) {
            my $name = transport_type_name($type, 0);
            $state->adb_output(FAIL, "more than one $name");
        } else {
            my $name = transport_type_name($type, 1);
            $state->adb_output(FAIL, "no $name found");
        }
    } elsif ($command eq "host:kill") {
        $state->adb_output;
    } elsif ($command eq "root:") {
        if (!$state->{transport}) {
            $state->adb_output(FAIL, "no devices/emulators found");
        } elsif ($listener->{root}) {
            $state->adb_output(UNCOUNTED, "adbd is already running as root\n");
        } else {
            $state->adb_output(UNCOUNTED, "restarting adbd as root\n");
            $listener->{root} = 1;
        }
    } elsif ($command eq "unroot:") {
        if (!$state->{transport}) {
            $state->adb_output(FAIL, "no devices/emulators found");
        } elsif ($listener->{root}) {
            $state->adb_output(UNCOUNTED, "restarting adbd as non root\n");
            $listener->{root} = 0;
        } else {
            $state->adb_output(UNCOUNTED, "adbd not running as root\n");
        }
    } elsif ($command eq "remount:") {
        if (!$state->{transport}) {
            $state->adb_output(FAIL, "device offline (no transport)");
        } elsif ($listener->{root}) {
            $state->adb_output(UNCOUNTED, "remount succeeded\n");
        } else {
            $state->adb_output(UNCOUNTED, "Not running as root. Try \"adb root\" first.\n");
        }
    } elsif ($command =~ m{^internal:(.*)\z}s) {
        # Non standard adb commands for testing
        $state->internal($1);
    } elsif ($command =~ m{^host:(transport-|tport:)(any|usb|tcp|local)}) {
        my $tport = $1 eq "tport:";
        my $type = $2;
        my @devices = $listener->{devices}->transport($type);
        if (@devices == 1) {
            # Pass through to device. Leave connection open
            $state->{transport} = $devices[0];
            $state->adb_output(UNCOUNTED, $tport ? $state->{transport}->packed_id : "", 1);
        } elsif (@devices) {
            my $name = transport_type_name($type, 0);
            $state->adb_output(FAIL, "more than one $name");
        } else {
            # on adb v39 this leaves the connection open, on v41 it closes
            my $name = transport_type_name($type, 1);
            $state->adb_output(FAIL, "no $name found", 1);
        }
    } elsif ($command =~ m{^host:(transport|tport:serial):(.*)}s) {
        my $tport = $1 eq "tport:serial";
        my $serial = $2;
        if (my $device = $listener->{devices}->get($serial)) {
            $state->{transport} = $device;
            $state->adb_output(UNCOUNTED, $tport ? $state->{transport}->packed_id : "", 1);
        } else {
            # on adb v39 this leaves the connection open, on v41 it closes
            $state->adb_output(FAIL, "device '$serial' not found");
        }
    } else {
        if ($command =~ /^host:/) {
            $state->adb_output(FAIL, "unknown host service");
        } elsif (0) {
            # Have transport
            $state->adb_output(FAIL, "closed");
        } else {
            $state->adb_output(FAIL, "device offline (no transport)");
        }
        # $state->adb_output(FAIL, "unknown host service:" . display_string($command));
    }
}

# Non standard adb commands for testing
sub internal {
    my ($state, $command) = @_;

    my $listener = $state->{listener};
    if ($command =~ m{^echo:(.*)\z}s) {
        # Fake command for response testing
        $state->adb_output(OKAY, $1);
    } elsif ($command eq "pid") {
        # Fake command: identify running process
        $state->adb_output(OKAY, $$);
    } elsif ($command eq "argv") {
        # Fake command: Show commandline
        $state->adb_output(OKAY, join("\0", @argv_old));
    } elsif (my ($serial) = $command =~ m{^device_add:(.*)\z}s) {
        # Fake command: Add device
        my $serial = $1;
        if ($listener->{devices}->get($serial)) {
            $state->adb_output(FAIL, "Already have device $serial");
        } elsif (!$devices{$serial}) {
            $state->adb_output(FAIL, "Unknown device $serial");
        } else {
            my $device = $listener->{devices}->add($serial);

            $device->offline;
            my $str = $listener->{devices}->string;
            $str = sprintf("%04X", length $str) . $str;
            for my $state (values %{$listener->{trackers}}) {
                $state->output($str);
            }

            $device->online;
            $str = $listener->{devices}->string;
            $str = sprintf("%04X", length $str) . $str;
            for my $state (values %{$listener->{trackers}}) {
                $state->output($str);
            }

            # Send result
            $state->adb_output(OKAY, "Added");
        }
    } elsif (($serial) = $command =~ m{^device_drop:(.*)\z}s) {
        # Fake command: Drop device
        my $serial = $1;
        if (my $device = $listener->{devices}->get($serial)) {
            # Take device offline
            $device->offline;
            my $str = $listener->{devices}->string;
            $str = sprintf("%04X", length $str) . $str;
            for my $state (values %{$listener->{trackers}}) {
                $state->output($str);
            }

            # Drop device
            $listener->{devices}->drop($serial);
            $str = $listener->{devices}->string;
            $str = sprintf("%04X", length $str) . $str;
            for my $state (values %{$listener->{trackers}}) {
                $state->output($str);
            }

            # Send result
            $state->adb_output(OKAY, "Dropped");

            # Close all acepted connections that use this device as transport
            # Last because this can close our own connection
            for my $state (values %{$listener->{accepted}}) {
                $state->adb_close if $state->{transport} == $device;
            }
        } else {
            $state->adb_output(FAIL, "No such device");
        }
    } else {
        $command = display_string($command);
        $state->adb_output(FAIL, "unknown internal command $command");
    }
}

package Listener;
sub DESTROY {
    # print STDERR "DESTROY(@_)\n";
    my ($listener) = @_;

    # Rescue sockets so they will get closed by the final _exit
    push @sockets, $listener->{socket} if $finish;
    $listener->{type} == ::UNACCEPTABLE ||
        $listener->{type} == ::UNREACHABLE ||
        $listener->{socket}->delete_read;

    --$listening;
}

sub close {
    my $listener = shift // return;
    # Early test makes sure that the final socket closes get done by _exit
    # This makes sure that if the client sees EOF the process is actually gone
    if (keys %listeners == 1) {
        ::finish();
    } else {
        delete $listeners{$listener->{key}};
        $listener = undef;
    }
}

package Device;
sub new {
    my ($class, $transport_id, $serial, $state, $description, $features) = @_;

    ++$devices;
    return bless {
        serial		=> $serial,
        transport_id	=> $transport_id,
        state		=> $state,
        description	=> $description,
        features	=> $features,
        root		=> 0,
    }, $class;
}

sub transport_id {
    return shift->{transport_id};
}

sub packed_id {
    return pack("q", shift->transport_id);
}

sub serial {
    return shift->{serial};
}

sub offline {
    my ($device) = @_;

    $device->{state} = "offline";
}

sub online {
    my ($device) = @_;

    $device->{state} = "device";
}

sub string {
    my ($device) = @_;

    return join "\t", @$device{qw(serial state)};
}

sub string_long {
    my ($device) = @_;

    return join("\t", @$device{qw(serial state description)}) . " transport_id:$device->{transport_id}";
}

sub features_string {
    my ($device) = @_;

    return join "," => @{$device->{features}};
}

sub usb {
    my ($device) = @_;

    return $device->{description} =~ m{(?:^| )usb:(\S+)} ? $1 : undef;
}

sub DESTROY {
    --$devices;
}

package Devices;

sub init {
    my $devices = bless {
        transport_ids => 0,
        devices => {},
    }, shift;
    for my $serial (sort keys %devices) {
        $devices->add($serial);
    }
    return $devices;
}

sub add {
    my ($devices, $serial) = @_;

    my $device = Device->new(++$devices->{transport_ids}, $serial,
                             @{$devices{$serial}});
    die "Duplicate device $serial" if $devices->{devices}{$serial};
    $devices->{devices}{$serial} = $device;
    return $device;
}

sub count {
    return scalar keys %{shift->{devices}};
}

sub string {
    return join "" => map $_->string . "\n" => shift->all;
}

sub string_long {
    return join "" => map $_->string_long . "\n" => shift->all;
}

sub all {
    my ($devices) = @_;

    return @{$devices->{devices}}{sort keys %{$devices->{devices}}};
}

sub drop {
    my ($devices, $serial) = @_;

    return delete $devices->{devices}{$serial};
}

sub get {
    my ($devices, $serial) = @_;

    return $devices->{devices}{$serial};
}

sub transport {
    my ($devices, $serial) = @_;

    if ($serial eq "any" || $serial eq "tcp") {
        return $devices->all;
    } elsif ($serial eq "usb") {
        return grep $_->usb => $devices->all;
    } elsif ($serial eq "local") {
        return grep !$_->usb => $devices->all;
    } else {
        die "Not implemented '$serial'";
    }
}

package main;
event_init();
$idle_timeout = unidle();
eval { main() };
if ($@) {
    select(STDERR);
    $| = 1;
    print $@;
    _exit(255);
}
_exit(0);
