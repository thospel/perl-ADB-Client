#!/usr/bin/perl -w

my $sleep;
BEGIN {
    $sleep = $ENV{ADB_FAKE_SLEEP} || 0;
    if ($sleep < 0) {
        # Do this as early as possible in the hope that TERM won't arrive
        # before we set the signal handler
        $SIG{TERM} = "IGNORE";
        $sleep = -$sleep;
    }
}

use strict;
use warnings;

our $VERSION = "1.000";

use FindBin qw($Script);
our $Bin;

# If the program runs as /foobar/bin/program, find libraries in /foobar/lib
BEGIN {
    # Even on windows FindBin uses / in the reported path
    $Bin = $FindBin::Bin;
    $Bin =~ s{/+\z}{};
    $Bin =~
        ($^O eq "MSWin32" ?
         qr{^((?:[A-Z]:)?(?:/[a-zA-Z0-9_:.~ -]+)*)/[a-zA-Z0-9_.-]+/*\z} :
         qr{^((?:/[a-zA-Z0-9_:.-]+)*)/[a-zA-Z0-9_.-]+/*\z}) ||
         die "Could not parse bin directory '$Bin'";
    # Use untainted version of lib
    require lib;
    # Support a simple --blib option for pre-install testing
    "lib"->import(@ARGV && $ARGV[0] eq "--blib" ? shift && "$1/blib/lib" : "$1/lib");
}

use IO::Socket qw(IPPROTO_TCP TCP_NODELAY);
use IO::Socket::IP qw();
use Scalar::Util qw(weaken refaddr);
use Getopt::Long 2.24 qw(:config bundling);
use POSIX qw(_exit);
use Errno qw(EAGAIN EINTR EWOULDBLOCK);
use Data::Dumper;

use ADB::Client::Events qw(mainloop timer event_init);
use ADB::Client::Utils qw(info display_string ip_port_from_addr IPV6);

use constant {
    CONTROL	=> 0,	# Control port
    LISTENER	=> 1,	# Normal fake adb server
    UNACCEPTABLE=> 2,	# Doesnt' even accept connections (OS will accept)
    UNREACHABLE	=> 3,	# Occupies a port but refuses connection (no listen)
    BLACKHOLE	=> 4,	# Eats everything on the accepted connection. Can talk
    ECHO	=> 5,	# Echoes whatever you type

    NULL	=> "/dev/null",
};

my $IDLE_TIMEOUT = 10;

$| = 1;

my $Listen = "tcp:localhost:5037";

my @argv_old = @ARGV;
die "Could not parse your command line. Try $0 -h\n" unless
    GetOptions("a!"		=> \my $all,
               "L=s"		=> \$Listen,
               "reply-fd=o"	=> \my $reply_fd,
               "acceptfd=o"	=> \my $accept_fd,
               "version|V=o"	=> \my $adb_version,
               # Non standard options
               "verbose|v!"	=> \my $verbose,
               "timeout|t=o"	=> \my $idle_timeout,
           );
$idle_timeout //= $verbose ? 1200 : $IDLE_TIMEOUT;

# Little set of model devices
my %devices = (
    "52000c4748d6a283" => {
        state		=> "device",
        description	=> "product:lineage_kminilte model:SM_G800F device:kminiltexx",
        features	=> [qw(shell_v2 cmd stat_v2 wabbits)],
        ip		=> "10.253.0.11",
        listening_adb	=> 1234,
    },
    "0715f712da553032" => {
        state		=> "device",
        description	=> "product:zerofltexx model:SM_G920F device:zeroflte",
        features	=> [qw(fixed_push_mkdir shell_v2 apex stat_v2 abb fixed_push_symlink_timestamp cmd abb_exec zorro)],
        ip		=> "10.253.0.13",
        listening_adb	=> 5555,
    },
);
my %serial_from_ip;
my $device_listening_adb = {};
{
    my $i = "0";
    for my $serial (sort keys %devices) {
        $serial_from_ip{$devices{$serial}{ip}} = $serial;
        $devices{$serial}{serial_usb} = $serial;
        $devices{$serial}{usb} = "usb:1-1." . ++$i;
        $device_listening_adb->{$serial} = delete($devices{$serial}{listening_adb}) || 0;
    }
}
my @init_devices = qw(10.253.0.13:5555 52000c4748d6a283);

# my @host_features = qw(shell_v2cmd push_sync stat_v2);
my @host_features = qw(shell_v2 cmd stat_v2 ls_v2 fixed_push_mkdir apex abb fixed_push_symlink_timestamp abb_exec remount_shell track_app sendrecv_v2 sendrecv_v2_brotli sendrecv_v2_lz4 sendrecv_v2_zstd sendrecv_v2_dry_run_send push_sync);
my %host_features = map(($_ => 1), @host_features);

# Make sure we will quit by ourselves after inactivity so testing won't get
# stuck in case of errors in adb_fake
my $nr_accepted = my $nr_listening = my $nr_devices = 0;
my ($finish, $idle_timer, $alarm_timer, %listeners, %specials, @sockets);

our $BLOCK_SIZE = 65536;
# Default ADB version for plain adb_fake
our $ADB_VERSION = $adb_version || 39;
# Default ADB version for adb_fake with arguments (called like real adb)
our $ADB_VERSION2 = $adb_version || 30;
our $TIMEOUT	= 2;

sub acceptable {
    my ($listener) = @_;

    my $addr = accept(my $socket, $listener->{socket});
    if (!$addr) {
        return if $! == EAGAIN || $! == EINTR || $! == EWOULDBLOCK;
        die "Accept error: $^E";
    }
    unidle();
    $socket->blocking(0);
    setsockopt($socket, IPPROTO_TCP, TCP_NODELAY, 1) ||
        die("Could not set TCP_NODELAY on accepted socket: $^E");
    my $class = $listener->{type} == CONTROL ? "Control" : "ADB";
    my $state = $class->new($socket, $listener->{type}, $listener->next_id);
    weaken($state->{listener} = $listener);
    $listener->{accepted}{$state->{key}} = $state;
    $state->{reader} = $socket->add_read($state, \&Accepted::reader);
    if ($listener->{type} == BLACKHOLE) {
        $state->output($listener->{arg}{hello}) if $listener->{arg}{hello} ne "";
        $state->{bytes_left} = $listener->{arg}{n};
        $state->adb_close_soon if $state->{bytes_left} <= 0;
    }
    $state->output("adb_fake $VERSION\n") if $listener->{type} == CONTROL;
}

sub add_listener {
    my ($type, $arg, $host, $port) = @_;
    $type = shift // LISTENER;

    $host ||= "127.0.0.1";
    $port ||= 0;
    my $socket = defined fileno $port ? $port :
        IO::Socket::IP->new(
            $type == UNREACHABLE ? () : (Listen => 5),
            V6Only	=> 0,
            ReuseAddr	=> 1,
            LocalHost	=> $host,
            LocalPort	=> $port) ||
            die "Could not create listening socket $host:$port: $^E";
    # Workaroud for bind bug in IO::Socket::IP
    # (failing bind does not lead to fatal error, seen in verson 0.39)
    # And we want to set blocking 0 for acceptfd anyways
    $socket->blocking(0);
    my $addr = getsockname($socket) || die "Could not getsockname: $^E";
    $port = (ip_port_from_addr($addr))[1];
    my $key = refaddr($socket);
    my $listener = bless {
        key		=> $key,
        ids		=> 0,
        socket		=> $socket,
        port		=> $port,
        accepted	=> {},
        device_events	=> {},
        type		=> $type,
        arg		=> $arg,
        $type == LISTENER ? (version => $arg // $ADB_VERSION) : (),
    }, "Listener";
    ++$nr_listening;
    if ($type == LISTENER) {
        $listeners{$key} = $listener;
        $listener->devices_init;
    } else {
        $specials{$key} = $listener;
    }
    $listener->{reader} = $socket->add_read($listener, \&acceptable) if
        $type != UNACCEPTABLE && $type != UNREACHABLE;
    return $listener->{port};
}

sub finish {
    info("finish") if $verbose;
    $finish = 1;
    $idle_timer = undef;
    $alarm_timer = undef;
    %specials = ();
    %listeners = ();
}

sub timed_out {
    print STDERR "Timed out after $idle_timeout seconds of inactivity\n";
    finish();
}

my $dummy_obj = bless [];
# Push the idle timeout forward
sub unidle {
    $idle_timer = timer($idle_timeout, $dummy_obj, \&timed_out);
}

# Push the alarm forward
sub unalarm {
    $alarm_timer = timer($idle_timeout, $dummy_obj, \&unalarm);
    # This alarm should never trigger.
    # But it's our last resort in case the event system gets stuck
    alarm $idle_timeout + 3;
}

sub dumper {
    my ($msg, $data) = @_;

    local $Data::Dumper::Indent	  = 1;
    local $Data::Dumper::Sortkeys = 1;
    local $Data::Dumper::Useqq	  = 1;
    local $Data::Dumper::Terse    = 1;

    $msg ||= "Data";
    return "$msg: " . Dumper($data);
}

my $sleeper;
sub daemon {
    $reply_fd //
        die "reply fd for adb server to client communication not specified.\n";
    $reply_fd =~ /^\d+\z/a ||
        die "reply_fd '$reply_fd' is not a natural number\n";
    open(my $reply, ">&=", $reply_fd) ||
        die "Could not fdopen $reply_fd: $^E\n";
    $reply->autoflush(1);

    open(STDOUT, ">", NULL) ||
        die "Could not open '" . NULL . "' as STDOUT: $^E";
    open(STDIN, "<", NULL) ||
        die "Could not open '" . NULL . "' as STDIN: $^E";

    # use ANDROID_ADB_LOG_PATH bin/adb_fake ... to keep STDERR
    if (my $log_path = $ENV{ANDROID_ADB_LOG_PATH} // NULL) {
        open(my $fh, ">", $log_path) || die "open($log_path): $^E\n";
        open(STDERR, ">&", $fh) || die "Cannot dup to STDERR: $^E";
        close($fh) || die "Could not close($log_path): $^E";
    }
    STDERR->autoflush(1);

    # Simulate an error
    my $err = $ENV{ADB_FAKE_ERROR};
    die $err if $err;

    my $port;
    if (my ($host, $p) = $Listen =~ m{^tcp:(?:(.*):)?(\d+)\z}a) {
        $host //= "localhost";
        $host eq "localhost" ||
            die "error: could not install *smartsocket* listener: listening on specified hostname currently unsupported (@argv_old)\n";
        $port = $p;
    } elsif (my ($fd) = $Listen =~ m{^acceptfd:(\d+)\z}a) {
        open($port, "<&=", $fd) || die "Could not fdopen $fd: $^E";
    } else {
        die "error: could not install *smartsocket* listener: unknown socket specification '$Listen'\n";
    }

    my $ip =
        !$all ? "127.0.0.1" :
        IPV6 ? "::" :
        "0.0.0.0";
    $sleeper = timer($sleep,
                     $dummy_obj,
                     sub {
        my $p = add_listener(LISTENER, $ADB_VERSION2, $ip, $port);
        my $OK = $port ? "OK" : "OK $p";
        print($reply "$OK\n") || die "Could not write to fd $reply_fd: $^E";
        close($reply) || die "Could not close fd $reply_fd: $^E";
    });
    mainloop();
}

sub main {
    if (@ARGV) {
        daemon();
    } else {
        my $port = add_listener(CONTROL);
        print("Port: $port\n") || die "print: $^E";
        mainloop();
        print("Close: $nr_listening $nr_accepted $nr_devices\n") ||
            die "Final print failed: $^E";
    }
}

package Accepted;
use Scalar::Util qw(weaken);
use Errno qw(ECONNRESET EAGAIN EINTR EWOULDBLOCK);

use ADB::Client::Utils qw(info string_from_value);
use ADB::Client::Events qw(timer);

sub listener {
    return shift->{listener};
}

sub reader {
    my ($state) = @_;

    my $rc = sysread($state->{socket}, my $buffer, $BLOCK_SIZE);
    if ($rc) {
        ::unidle();
        $state->{in} .= $buffer;
        eval { $state->{on_read}->($state, $rc) };
        $state->{on_error}->($state, $@) if $@;
        return $rc;
    }
    if (defined $rc || $! == ECONNRESET) {
        ::unidle();
        # EOF
        $state->{on_close}->($state, defined $rc ? 0 : $!);
        return;
    }
    return if $! == EAGAIN || $! == EINTR || $! == EWOULDBLOCK;
    ::unidle();
    die "Read error: $^E";
}

sub writer {
    my ($state) = @_;

    my $rc = syswrite($state->{socket}, $state->{out}, $BLOCK_SIZE);
    if ($rc) {
        ::unidle();
        my $written = substr($state->{out}, 0, $rc, "");
        info("Response(%s) > \t%s", $state->{id}, string_from_value($written)) if
            $verbose && $state->isa("ADB");;
        if ($state->{out} eq "") {
            $state->{writer} = undef;
            $state->{timeout} = undef;
            if (my $written = delete $state->{written}) {
                weaken($state);
                $written->($state);
            }
        }
        return;
    }
    # Dunno how to handle this.
    # Is it even possible ? Never found an answer
    die "Assertion: Length 0 write" if defined $rc;
    return if $! == EAGAIN || $! == EINTR || $! == EWOULDBLOCK;
    ::unidle();
    die "Write error: $^E";
}

sub output {
    my $state = shift;

    return if $state->{written};

    my $str = join("", @_);
    return if $str eq "";
    # Should always be downgraded, but let's be paranoid
    die "Unexpected upgrade string" if utf8::is_utf8($str);

    if ($state->{out} eq "") {
        $state->{writer} = $state->{socket}->add_write($state, \&writer);
        $state->{timeout} = timer($state->{write_timeout}, $state, sub {
                                      my $state = shift;
                                      $state->{on_error}->($state, "Write timed out") });
    }
    $state->{out} .= $str;
}

sub DESTROY {
    # print STDERR "DESTROY(@_)\n";
    my ($state) = @_;

    # Rescue sockets so they will get closed by the final _exit
    push @sockets, $state->{socket} if $finish;
    $state->{writer} = undef if $state->{out} ne "";
    --$nr_accepted;
}

sub dumper {
    my ($accepted, $msg) = @_;

    local $accepted->{listener} = "<listener>";
    $msg ||= "Accepted";
    $accepted->output(::dumper($msg, $accepted));
}

package Control;
use Scalar::Util qw(refaddr);
use ADB::Client::Utils qw(INFINITY);

our @ISA = qw(Accepted);

sub new {
    my ($class, $socket) = @_;

    ++$nr_accepted;
    return bless {
        key		=> refaddr($socket),
        socket		=> $socket,
        in		=> "",
        out 		=> "",
        on_read		=> \&control_read,
        on_close	=> \&::finish,
        on_error	=> sub { die $_[1]},
        write_timeout	=> $TIMEOUT,
    }, $class;
}

sub control_read {
    my ($state) = @_;

    while ($state->{in} =~ s/^[^\S\n]*(.*?)[^\S\n]*\n//) {
        my $command = lc($1);
        my $port;
        if ($command =~ m{listener(?:\s+(\d+))?\z}) {
            $port = ::add_listener(::LISTENER, $1 // $ADB_VERSION);
        } elsif ($command =~ m{listener6(?:\s+(\d+))?\z}) {
            $port = ::add_listener(::LISTENER, $1 // $ADB_VERSION, "::1");
        } elsif ($command =~ m{listener0(?:\s+(\d+))?\z}) {
            $port = ::add_listener(::LISTENER, $1 // $ADB_VERSION, "::");
        } elsif ($command eq "unacceptable") {
            $port = ::add_listener(::UNACCEPTABLE);
        } elsif ($command eq "unacceptable6") {
            $port = ::add_listener(::UNACCEPTABLE, undef, "::1");
        } elsif ($command eq "unreachable") {
            $port = ::add_listener(::UNREACHABLE);
        } elsif ($command eq "unreachable6") {
            $port = ::add_listener(::UNREACHABLE, undef, "::1");
        } elsif ($command =~ m{^blackhole(?:\s+([-?[0-9]+))?(?:\s(.*))?\z}) {
            my $n = $1 // -1;
            my $hello = $2 // "";
            $hello =~ s/\\n/\n/g;
            $n = INFINITY if $n < 0;
            $port = ::add_listener(::BLACKHOLE, { n => $n, hello => $hello});
        } elsif ($command eq "echo") {
            $port = ::add_listener(::ECHO);
        } elsif ($command eq "echo6") {
            $port = ::add_listener(::ECHO, undef, "::1");
        } elsif ($command eq "dump") {
            $state->dumper("State");
            return;
        } elsif ($command eq "quit") {
            ::finish();
            return;
        } elsif ($command eq "help") {
            $state->output('Valid commands (case insensitive):
Listener  [version]	Start a listener on 127.0.0.1
Listener6 [version]	Start a listener on ::1
Listener0 [version]	Start a listener on ::
Unacceptable		Start a listening port on 127.0.0.1 without accept
                        handler. Up to a point OS will accept for you though
Unacceptable6		Start a listening port on ::1 without accept handler
Unreachable		Start a non-listening port on 127.0.0.1
Unreachable6		Start a non-listening port on ::1
BlackHole [n] [hello]	Start a listener on 127.0.0.1 that sends "hello"
                        (defaults to nothing), reads n bytes (defaults to -1)
                        and then closes the connection. Negative n means keep
                        reading forever (untill the peer closes). "n" is
                        mandatory if "hello" looks like a number
Echo			Start a listener on 127.0.0.1 that echoes everything
Echo6			Start a listener on ::1 that echoes everything
Quit			Exit the program (not just the control connection)
Help			Show this help
Dump			Dump the current state

All listeners behave like independent ADB servers
');
            return;
        } elsif ($command eq "") {
            return;
        } else {
            $state->output("Unknown: <$command>\n");
            return;
        }
        $state->output("Port: $port\n");
    }
}

package ADB;
use Errno qw(ENOENT);
use Scalar::Util qw(refaddr weaken);
use Carp;
# use ADB::Client::Utils qw(callers);
use ADB::Client::Utils qw(%adb_mode_from_file_type
                          errno_adb_from_native string_from_value
                          display_string info time_to_adb time_from_adb
                          adb_file_type_from_mode adb_permissions_from_mode);

use constant {
    # perl stat() fields
    DEV		=> 0,
    INO		=> 1,
    MODE	=> 2,
    NLINK	=> 3,
    UID		=> 4,
    GID		=> 5,
    SIZE	=> 7,
    ATIME	=> 8,
    MTIME	=> 9,
    CTIME	=> 10,
};

our @ISA = qw(Accepted);

use constant {
    FAIL	=> 0,
    OKAY	=> 1,
    UNCOUNTED	=> 2,
};

sub new {
    my ($class, $socket, $type, $id) = @_;

    info("Accept  (%s)", $id) if $verbose;
    ++$nr_accepted;
    return bless {
        key		=> refaddr($socket),
        id		=> $id,
        socket		=> $socket,
        in		=> "",
        out 		=> "",
        on_read		=>
        $type == ::LISTENER	? \&adb_read :
        $type == ::BLACKHOLE	? \&adb_closer :
        $type == ::ECHO		? \&adb_echo :
        die("Unhandled type $type"),
        on_error	=> \&adb_error,
        on_close	=> \&adb_close,
        write_timeout	=> $TIMEOUT,

        sync		=> 0,
        transport	=> 0,
        forward		=> {},
        # Maybe reverse should be on the device ?
        reverse		=> {},
    }, $class;
}

sub adb_error {
    my ($state, $err) = @_;

    warn($err);
    $state->adb_close;
}

sub adb_close {
    my ($state) = @_;

    # Carp::cluck("Close");
    info("Close   (%s)", $state->{id}) if $verbose;
    # print STDERR "ADB CLOSE ", callers();
    # This can get called during _reader which will inspect this after return
    $state->{on_read} = \&adb_discard;
    delete $state->{listener}{accepted}{$state->{key}};
    delete $state->{listener}{device_events}{$state->{key}};
}

sub adb_close_soon {
    my ($state) = @_;

    if ($state->{out} eq "") {
        $state->adb_close;
    } elsif (!$state->{written}) {
        $state->{on_read} = \&adb_discard;
        $state->{written} = \&adb_close;
    }
}

sub adb_discard {
    my ($state, $rc) = @_;

    $state->{in} = "";
}

sub adb_closer {
    my ($state, $rc) = @_;

    info("Discard (%s) > \t%s", $state->{id}, string_from_value($state->{in})) if $verbose;

    $state->{bytes_left} -= $rc;
    $state->adb_close_soon if $state->{bytes_left} <= 0;
    $state->{in} = "";
}

sub adb_echo {
    my ($state, $rc) = @_;

    info("Echo    (%s) > \t%s", $state->{id}, string_from_value($state->{in})) if $verbose;
    $state->output($state->{in});
    $state->{in} = "";
}

sub wait_interrupt {
    my ($state, $rc) = @_;

    delete $state->listener->{device_events}{$state->{key}};
    $state->adb_output(FAIL, $state->{interrupt_message});
    $state->{in} = "";
}

my %command_sync = (
    QUIT	=> \&adb_close,
    STAT	=> \&command_lstat_v1,
    LST2	=> \&command_lstat_v2,
    STA2	=> \&command_lstat_v2,
    LIST	=> \&command_list_v1,
    RECV	=> \&command_recv_v1,
    SEND	=> \&command_send_v1,
);

sub adb_read {
    my ($state, $rc) = @_;

    my $len = length $state->{in};
    while ($state->{in} ne "") {
        # For convenient debugging with telnet...
        next if $state->{in} =~ s/^[\r\n]+//;
        if ($state->{sync}) {
            length $state->{in} >= 8 || return;
            my $bytes = unpack("V", substr($state->{in}, 4, 4));
            length $state->{in} >= 8+$bytes || return;
            my $arguments = substr($state->{in}, 0, 8+$bytes, "");
            my $command = substr($arguments, 0, 4);
            substr($arguments, 0, 8, "");

            info("Command (%s) <\t'%s %s'", $state->{id}, $command, $arguments) if $verbose;

            if (my $code = $command_sync{$command}) {
                $code->($state, $arguments, $command);
            } else {
                $command = lc unpack("H*", reverse $command);
                $state->adb_sync_fail("unknown command $command");
            }
        } else {
            length $state->{in} >= 4 || return;
            my $code = substr($state->{in}, 0, 4);
            $code =~ /^[0-9a-fA-F]{4}\z/ ||
                die "Invalid length code: ", display_string($code);
            my $len = hex $code;
            length $state->{in} >= 4 + $len || return;
            my $command = substr($state->{in}, 0, 4 + $len, "");
            substr($command, 0, 4, "");
            $state->adb_command($command);
        }
        if ($state->{on_read} != \&adb_read) {
            if ($state->{in} ne "") {
                $rc -= $len - length $state->{in};
                $state->{on_read}->($state, $rc);
            }
            last;
        }
    }
}

sub send_read {
    my ($state) = @_;

    while (length $state->{in} >= 4) {
        my ($id, $length) = unpack("a4V", $state->{in});
        if ($id eq "DATA") {
            defined $length && length $state->{in} >= 8 + $length || return;
            substr($state->{in}, 0, 8, "");
            my $fh = $state->{send_fh};
            if (!print($fh substr($state->{in}, 0, $length, ""))) {
                $state->adb_sync_fail("Could not close '$state->{send_file}': $^E");
                last;
            }
        } elsif ($id eq "DONE") {
            defined $length || return;
            substr($state->{in}, 0, 8, "");
            my $file = delete $state->{send_file};
            my $path = $state->sync_filecheck($file) // return;
            if (!close(delete $state->{send_fh})) {
                $state->adb_sync_fail("Could not close '$file': $^E");
                last;
            }
            my $mtime = time_from_adb($length);
            if (!utime($mtime, $mtime, $path)) {
                $state->adb_sync_fail("Could not utime '$file': $^E");
                last;
            }
            $state->output(pack("a4x4", "OKAY"));
            # Resume normal command processing
            $state->{on_read} = \&adb_read;
            return;
        } else {
            $state->adb_sync_fail("invalid data message");
            last;
        }
    }
    unlink($state->{send_path}) ||
        die "Could not unlink just created '$state->{send_path}': $^E";
}

sub adb_output {
    my ($state, $status, $response, $keep_open) = @_;

    return if $state->{written};

    if (defined $status) {
        if ($status == UNCOUNTED) {
            $state->output("OKAY" . $response);
        } else {
            $state->output(
                ($status ? "OKAY" : "FAIL"),
                sprintf("%04X", length $response),
                $response);
            # $state->{written} = \&adb_close;
        }
        $state->adb_close_soon if !$keep_open || $status == FAIL;
    } else {
        # Close after OKAY send (used by host:kill)
        $state->output("OKAY");
        weaken(my $listener = $state->{listener});
        $state->{written} = sub { $listener->close if $listener};
    }
}

sub adb_sync_fail {
    my ($state, $err) = @_;

    die "Already have 'written" if $state->{written};
    $state->output(pack("a*V/a*", "FAIL", $err));
    $state->adb_close_soon;
}

sub transport_type_name {
    my ($type, $many) = @_;

    return $many ? "devices/emulators" : "device/emulator" if $type eq "any";
    return $many ? "devices"           : "device"          if $type eq "usb";
    return $many ? "emulators"         : "emulator"        if $type eq "local";
    die "Unknown transport type '$type'";
}

my %command_transporter = (
    "root"			=> \&command_root,
    "unroot"			=> \&command_unroot,
    "reboot:"			=> \&command_reboot,
    "enable-verity"		=> \&command_empty,
    "disable-verity"		=> \&command_empty,
    "remount"			=> \&command_remount,
    "reverse:forward:"		=> \&command_reverse,
    "reverse:list-forward"	=> \&command_reverse_list,
    "reverse:killforward:"	=> \&command_reverse_kill,
    "reverse:killforward-all"	=> \&command_reverse_kill_all,
    "usb"			=> \&command_usb,
    "tcpip:"			=> \&command_tcpip,
    "sync"			=> \&command_sync,
);

my $command_transporter_regex =
    join("|", map(quotemeta($_) . ($_ =~ /:\z/ ? '' :
                                   $_ =~ /:/ ? '\z' :
                                   '(?=:\z)'),
                  sort keys %command_transporter));
$command_transporter_regex = qr{^($command_transporter_regex)(.*)\z};

sub command_reboot {
    my ($state, $device, $type) = @_;

    # Real devices dont care. They reboot for every argument
    if ($type =~ /^(?:bootloader|recovery|sideload|sideload-auto-reboot|)\z/) {
        # We could now waste a bit of time before coming back
        # No need to be so realistic though
        $state->adb_output(UNCOUNTED, "");
        $state->{transport} = 0;
        $device->reconnect($type || "device");
    } else {
        $state->adb_output(FAIL, "Unknown reboot type");
    }
}

sub command_root {
    my ($state, $device) = @_;
    if ($device->root) {
        $state->adb_output(UNCOUNTED, "adbd is already running as root\n");
    } else {
        $state->adb_output(UNCOUNTED, "restarting adbd as root\n");
        $state->{transport} = 0;
        $device = $device->reconnect;
        $device->root(1);
    }
}

sub command_unroot {
    my ($state, $device) = @_;

    if ($device->root) {
        $state->adb_output(UNCOUNTED, "restarting adbd as non root\n");
        $state->{transport} = 0;
        $device->reconnect;
        $device->root(0);
    } else {
        $state->adb_output(UNCOUNTED, "adbd not running as root\n");
    }
}

sub command_empty {
    my ($state) = @_;

    $state->adb_output(UNCOUNTED, "");
}

sub command_remount {
    my ($state, $device) = @_;

    if ($device->root) {
        $state->adb_output(UNCOUNTED, "remount succeeded\n");
    } else {
        $state->adb_output(UNCOUNTED, "Not running as root. Try \"adb root\" first.\n");
    }
}

sub command_reverse_list {
    my ($state, $device) = @_;

    my $listener = $state->{listener};
    my $serial = $device->serial;

    my $out = "";
    my $reverses = $listener->{reverse}{$serial} || {};
    for my $from (sort keys %$reverses) {
        $out .= "(reverse) $from $reverses->{$from}\n";
    }
    $state->adb_output(OKAY, $out);
}

sub command_reverse {
    my ($state, $device, $arguments) = @_;

    my $listener = $state->{listener};
    my $serial = $device->serial;
    my $no_rebind = $arguments =~ s/^norebind://;
    if (my ($from, $to) = $arguments =~ /^([^;]+);([^;]+)\z/) {
        if ($from =~ /^(?:tcp:(\d+)|(?:localabstract|localreserved|localfilesystem):(.*))\z/a) {
            # I haven't actualy investigated any of these except tcp:<port>
            # So the output format for the other case is likely nonsense
            my $port = $+ || 1024 + int rand(2**16-1024);
            if ($port < 1024) {
                $state->adb_output(FAIL, "cannot bind listener: Permission denied");
            } else {
                $from = "tcp:$port" if !$+;
                if (exists $listener->{reverse}{$serial}{$from}) {
                    if ($no_rebind) {
                        $state->adb_output(FAIL, "cannot rebind existing socket");
                        return;
                    }
                    $state->adb_output(UNCOUNTED, "OKAY");
                } else {
                    $state->adb_output(UNCOUNTED, "", 1);
                    $state->adb_output(OKAY, $port);
                }
                $listener->{reverse}{$serial}{$from} = $to;
            }
        } else {
            $state->adb_output(FAIL, "cannot bind listener: unknown socket specification:$from");
        }
    } else {
        $state->adb_output(FAIL, "bad forward: $arguments");
    }
}

sub command_reverse_kill {
    my ($state, $device, $from) = @_;

    my $listener = $state->{listener};
    my $serial = $device->serial;
    my $reverses = $listener->{reverse};
    if (delete $reverses->{$serial}{$from}) {
        delete $reverses->{$serial} if !%{$reverses->{$serial}};
        $state->adb_output(UNCOUNTED, "OKAY");
    } else {
        $state->adb_output(FAIL, "listener '$from' not found");
    }
}

sub command_reverse_kill_all {
    my ($state, $device) = @_;

    my $listener = $state->{listener};
    my $serial = $device->serial;
    delete $listener->{reverse}{$serial};
    $state->adb_output(UNCOUNTED, "OKAY");
}

sub command_tcpip {
    my ($state, $device, $port) = @_;

    $state->adb_output(UNCOUNTED, "restarting in TCP mode port: $port\n");
    # Close any old open connection
    $device->listening_adb($port);
}

sub command_usb {
    my ($state, $device) = @_;

    $state->adb_output(UNCOUNTED, "restarting in USB mode\n");
    # Close any old open connection
    $device->listening_adb(0);
}

sub command_sync {
    my ($state, $device) = @_;

    $state->{sync} = 1;
    $state->adb_output(UNCOUNTED, "", 1);
}

sub adb_command {
    my ($state, $command) = @_;
    info("Command (%s) <\t'%s'", $state->{id}, $command) if $verbose;

    if ($command =~ m{^host(-usb|-local|-transport-id:(\d+)|-serial:([^:]*(?::\d+)?)|):(.*)\z}a) {
        $state->command_host(
            $1 eq ""		? "any" :
            $1 eq "-usb"	? "usb" :
            $1 eq "-local"	? "local" :
            defined $2		? "id" :
            defined $3		? "serial" :
            croak("Impossible type $1"), $2, $3, $4);
    } elsif ($command =~ m{^internal:(.*)\z}s) {
        # Non standard adb commands for testing
        $state->command_internal($1);
    } elsif ($state->{transport}) {
        # Have transport
        if ($command =~ /$command_transporter_regex/o) {
            my $sub_command = $1;
            my $arguments   = $2;
            my $code = $command_transporter{$sub_command} ||
                die "Assertion: Could not find command_transport{$sub_command}";
            $code->($state, $state->{transport}, $arguments, $sub_command);
        } else {
            $state->adb_output(FAIL, "closed");
        }
    } else {
        $state->adb_output(FAIL, "device offline (no transport)");
    }
}

my %command_serial = (
    features		=> \&command_features,
    "get-serialno"	=> \&command_get_serialno,
    "get-state"		=> \&command_get_state,
    "get-devpath"	=> \&command_get_devpath,
    "forward:"		=> \&command_forward,
);
my $command_serial_regex =join("|",
                               map(quotemeta($_) . ($_ =~ /:\z/ ? '' : '\z'),
                                   sort keys %command_serial));
$command_serial_regex = qr{^($command_serial_regex)(.*)\z};

sub command_host {
    my ($state, $type, $id, $serial, $command) = @_;

    # Make transport more like tport
    $command =~ s/^transport:/transport:serial:/;
    $command =~ s/^transport-/transport:/;

    my $listener = $state->{listener};
    if ($command eq "version") {
        $state->adb_output(OKAY, sprintf("%04X", $listener->{version}));
    } elsif ($command eq "kill") {
        $state->adb_output;
    } elsif ($command eq "devices") {
        $state->adb_output(OKAY, $listener->{devices}->string);
    } elsif ($command eq "devices-l") {
        $state->adb_output(OKAY, $listener->{devices}->string_long);
    } elsif ($command eq "track-devices") {
        $state->adb_output(OKAY, $listener->{devices}->string, 1);
        # Become a tracker
        $state->{transport} = 0;
        $listener->{device_events}{$state->{key}} = $state;
        $state->{on_device_event} = \&tracker,
        $state->{on_read} = \&adb_close;
    } elsif ($command eq "host-features") {
        $state->adb_output(OKAY, join "," => @host_features);
    } elsif ($command =~ m{^connect:(.*?)(?::(\d+))?\z}as) {
        my $host = $1;
        my $port = $2 || 5555;
        # Real ADB does name resolution
        my $serial = "$host:$port";
        # For the real adb if it could make the connection but not talk the
        # device it is added in state "offline".
        # I didn't bother to implement an example of that.
        if ($listener->{devices}->get($serial)) {
            # Notice this is NOT a FAIL
            $state->adb_output(OKAY, "already connected to $serial");
        } elsif ($listener->device_add($serial, 1)) {
            $state->adb_output(OKAY, "connected to $serial");
        } else {
            # Several kinds of other connect and resolution errors are possible
            # Notice this is NOT a FAIL
            $state->adb_output(
                OKAY,"failed to connect to '$serial': Connection refused");
        }
    } elsif ($command =~ m{^disconnect:((.*?)(?::(\d+))?)\z}as) {
        my $name = $1;
        my $host = $2;
        my $port = $3 || 5555;
        # Real ADB does name resolution
        my $serial = "$host:$port";
        if (my $device = $listener->{devices}->get($serial)) {
            $state->adb_output(OKAY, "disconnected $name");
            # AFTER adb_output since this can close $state
            $device->drop;
        } else {
            $state->adb_output(FAIL, "no such device '$serial'");
        }
    } elsif ($command =~ /$command_serial_regex/o) {
        my $sub_command = $1;
        my $arguments   = $2;
        my $code = $command_serial{$sub_command} ||
            die "Assertion: Could not find command_serial{$sub_command}";
        #$listener->{devices}->dumper;
        my @devices = $listener->{devices}->transport($type, $id, $serial, $state->{transport});
        if (@devices == 1) {
            if ($devices[0]->is_offline) {
                my $offline = $devices[0]->state;
                $state->adb_output(FAIL, "device $offline");
            } else {
                $code->($state, $devices[0], $arguments, $sub_command);
            }
        } elsif (@devices) {
            my $name = transport_type_name($type, 0);
            $state->adb_output(FAIL, "more than one $name");
        } elsif (defined $id) {
            $state->adb_output(FAIL, "no device with transport id '$id'");
        } elsif (defined $serial) {
            $state->adb_output(FAIL, "device '$serial' not found");
        } else {
            my $name = transport_type_name($type, 1);
            $state->adb_output(FAIL, "no $name found");
        }
    } elsif ($command eq "list-forward") {
        my $out = "";
        my $forwards = $listener->{forward};
        for my $from (sort keys %$forwards) {
            $out .= "$forwards->{$from}[0] $from $forwards->{$from}[1]\n";
        }
        $state->adb_output(OKAY, $out);
    } elsif ($command eq "killforward-all") {
        %{$listener->{forward}} = ();
        $state->adb_output(UNCOUNTED, "OKAY");
    } elsif ($command =~ m{^killforward:(.*)}) {
        # The real host:killforward demands a transport
        my $from = $1;
        my $forwards = $listener->{forward};
        if (delete $forwards->{$from}) {
            $state->adb_output(UNCOUNTED, "OKAY");
        } else {
            $state->adb_output(FAIL, "listener '$from' not found");
        }
    } elsif ($command =~ m{^wait-for-(any|usb|local)-(device|recovery|rescue|sideload|bootloader|disconnect)\z}) {
        my $type  = $1 || $type;
        my $mode = $2;

        # disconnect is special since it tests a negative
        # Any "local" connections counts as disconnected
        # Multiple matches count as disconnected
        # So if you have one usb device connected and then connect another one
        # suddenly host:wait-for-usb-disconnect will return!
        $state->output("OKAY");
        my @devices = $listener->{devices}->transport($type, $id, $serial);
        if (@devices > 1) {
            if ($mode eq "disconnect") {
                $state->adb_output(UNCOUNTED, "");
            } else {
                my $name = transport_type_name($type, 0);
                $state->adb_output(FAIL, "more than one $name");
            }
            return;
        }
        if (@devices == 1) {
            if ($mode eq "disconnect") {
                if (!$devices[0]->usb || $devices[0]->is_offline) {
                    $state->adb_output(UNCOUNTED, "");
                    return;
                }
                if (defined $id) {
                    # implement transport-id wait via serial
                    $serial = $devices[0]->serial;
                    $type = "serial";
                }
            } elsif ($devices[0]->is_online) {
                $state->adb_output(UNCOUNTED, "");
                return;
            }
        } elsif ($mode eq "disconnect") {
            $state->adb_output(UNCOUNTED, "");
            return;
        }

        # No online devices. Become a waiter
        $listener->{device_events}{$state->{key}} = $state;
        # We will end with a close, but avoid others closing us
        # (not sure if this ever makes a difference)
        $state->{transport} = 0;
        $state->{on_device_event} = \&waiter;
        $state->{wait_type}   = $type;
        $state->{wait_mode}   = $mode;
        $state->{wait_serial} = $serial;
        $state->{interrupt_message} =
            $mode eq "disconnect" ? "success" :
            defined $id ? "no device with transport id '$id'" :
            defined $serial ? "device '$serial' not found" :
            sprintf("no %s found", transport_type_name($type, 1));
        $state->{on_read} = \&wait_interrupt,
    } elsif ($command =~ m{^(transport|tport):(any|usb|local|serial:(.*))}) {
        # host-local:tport:usb gets you usb
        # host-usb:tport:local gets you local
        # host-serial:0715f712da553032:tport:<anything> gets you that usb serial
        #  EXCEPT
        # host-serial:0715f712da553032:tport:serial:10.253.0.11:5555 gets local
        # host-transport-id:7:tport:<anything> gets you that transport id
        # host-transport-id:7:tport:serial:10.253.0.11:5555 still transport id
        # host:tport:transport-id:7 doesn't exist as valid syntax
        my $tport = $1 eq "tport";
        my $type = $2 || $type;
        $serial = $3 // $serial;
        my @devices = $listener->{devices}->transport($type, $id, $serial);
        if (@devices == 1) {
            if (!$devices[0]->is_offline) {
                # Pass through to device. Leave connection open
                $state->{transport} = $devices[0];
                $state->adb_output(UNCOUNTED, $tport ? $state->{transport}->packed_id : "", 1);
            } else {
                my $offline = $devices[0]->state;
                $state->adb_output(FAIL, "device $offline");
            }
        } elsif (@devices) {
            my $name = transport_type_name($type, 0);
            $state->adb_output(FAIL, "more than one $name");
        } elsif (defined $id) {
            $state->adb_output(FAIL, "no device with transport id '$id'");
        } elsif (defined $serial) {
            $state->adb_output(FAIL, "device '$serial' not found");
        } else {
            # on adb v39 this leaves the connection open, on v41 it closes
            my $name = transport_type_name($type, 1);
            $state->adb_output(FAIL, "no $name found", 1);
        }
    } else {
        $state->adb_output(FAIL, "unknown host service '$command'");
    }
}

sub command_features {
    my ($state, $device) = @_;

    $state->adb_output(OKAY, $device->features_string);
}

sub command_get_devpath {
    my ($state, $device) = @_;
    $state->adb_output(OKAY, $device->usb // "unknown");
}

sub command_get_serialno {
    my ($state, $device) = @_;
    $state->adb_output(OKAY, $device->serial);
}

sub command_get_state {
    my ($state, $device) = @_;
    $state->adb_output(OKAY, $device->state);
}

sub command_forward {
    my ($state, $device, $arguments) = @_;

    my $listener = $state->{listener};
    my $serial = $device->serial;
    my $no_rebind = $arguments =~ s/^norebind://;
    if (my ($from, $to) = $arguments =~ /^([^;]+);([^;]+)\z/) {
        if ($from =~ /^(?:(?:tcp|jdwp|acceptfd):(\d+)|(?:localabstract|localreserved|localfilesystem|dev):(.*))\z/a) {
            # I haven't actualy investigated any of these except tcp:<port>
            # So the output format for the other case is likely nonsense
            my $port = $+ || 1024 + int rand(2**16-1024);
            if ($port < 1024) {
                $state->adb_output(FAIL, "cannot bind listener: Permission denied");
            } else {
                $from = "tcp:$port" if !$+;
                if (exists $listener->{forward}{$from}) {
                    if ($no_rebind) {
                        $state->adb_output(FAIL, "cannot rebind existing socket");
                        return;
                    }
                    $state->adb_output(UNCOUNTED, "OKAY");
                } else {
                    $state->adb_output(UNCOUNTED, "", 1);
                    $state->adb_output(OKAY, $port);
                }
                $listener->{forward}{$from} = [$serial, $to];
            }
        } else {
            # The real adb outputs nothing
            # $state->adb_output(FAIL, "");
            $state->adb_output(FAIL, "bad from: $from");
        }
    } else {
        $state->adb_output(FAIL, "bad forward: $arguments");
    }
}

sub sync_filecheck {
    my ($state, $file) = @_;

    if ($file !~ m{^/}) {
        $state->adb_sync_fail("Not absolute");
        return undef;
    }
    if ("$file/" =~ m{/\.\./}) {
        # Avoid allowing people to explore the real filesystem
        $state->adb_sync_fail("Going backwards is not supported");
        return undef;
    }
    my $device = $state->{transport} ||
        die "Assertion: sync command without transport";
    my $root = $device->{filesystem};
    if (!$root) {
        my $serial = $device->serial;
        $state->adb_sync_fail("Device '$serial' has no filesystem");
        return undef;
    }
    return $root . $file;
}

sub stat_massage {
    my $lstat = shift ne "STA2";
    my $mode = $_[MODE] & 07777;
    if ($lstat && -l _) {
        $mode &= ~0133;
        $mode |= $adb_mode_from_file_type{"LINK"};
    } else {
        # Drop world read, copy user to group
        $mode &= ~0074;
        $mode |= $mode >> 3 & 070;
        $mode |= $adb_mode_from_file_type{-f _ ? "REG" : -d _ ? "DIR" : die "Unimplemented mode" };
    }
    $_[MODE]  = $mode;
    $_[UID] = $_[GID] = 0;
    for my $i (MTIME, CTIME, ATIME) {
        $_[$i] = time_to_adb($_[$i]);
    }
}

sub command_lstat_v1 {
    my ($state, $file, $command) = @_;

    my $path = $state->sync_filecheck($file) // return;
    if (my @stat = lstat($path)) {
        my $mode = $stat[MODE];
        stat_massage($command, @stat);
        $state->output(pack("a4V3", $command, @stat[MODE, SIZE, MTIME]));
    } else {
        $state->output(pack("a4x12", $command));
    }
}

sub command_lstat_v2 {
    my ($state, $file, $command) = @_;

    my $path = $state->sync_filecheck($file) // return;
    if (my @stat = $command eq "LST2" ? lstat($path) : stat($path)) {
        stat_massage($command, @stat);
        $state->output(pack("a4x4Q<Q<VVVVQ<q<q<q<", $command, @stat[DEV, INO, MODE, NLINK, UID, GID, SIZE, ATIME, MTIME, CTIME]));
    } else {
        $state->output(pack("a4Vx64", $command, errno_adb_from_native($!)));
    }
}

sub command_list_v1 {
    my ($state, $file, $command) = @_;

    my $path = $state->sync_filecheck($file) // return;
    if (opendir(my $dh, $path)) {
        while (my $f = readdir($dh)) {
            my @stat = lstat("$path/$f") or next;
            stat_massage($command, @stat);
            $state->output(pack("a4V3V/a*", "DENT",
                                @stat[MODE, SIZE, MTIME],
                                $f));
        }
    }
    $state->output(pack("a4x16", "DONE"));
}

sub command_recv_v1 {
    my ($state, $file) = @_;

    my $path = $state->sync_filecheck($file) // return;
    if (lstat($path)) {
        if (-f _) {
            # For now we only support regular files and not symlinks to them
            if (open(my $fh, "<", $path)) {
                binmode($fh);
                local $/ = \2**16;
                local $_;
                $state->output(pack("a4V/a*", "DATA", $_)) while <$fh>;
                $state->output(pack("a4x4", "DONE"));
            } else {
                my $err = errno_adb_from_native($!);
                $state->adb_sync_fail("read failed: $err");
            }
        } elsif (-d _) {
            # Special message for common case
            $state->adb_sync_fail("read failed: Is a directory");
        } else {
            # Some of these are valid but we have no tests that need them
            $state->adb_sync_fail("read failed: Not a regular file");
        }
    } else {
        my $err = errno_adb_from_native($!);
        $state->adb_sync_fail("read failed: $err");
    }
}

sub mkdirp {
    my ($state, $dir) = @_;

    $dir =~ s{/[^/]*\z}{} || die "Cannot shorten path '$dir'";
    return 1 if $dir eq "";
    my $path = $state->sync_filecheck($dir) // return;
    return 1 if -d $path;
    if (-e _) {
        $state->adb_sync_fail("couldn't create file: Not a directory");
        return;
    }
    $state->mkdirp($dir) // return;
    my $umask_old = umask(022);
    if (!mkdir($path)) {
        umask($umask_old);
        $state->adb_sync_fail("secure_mkdirs failed: $^E");
        return;
    }
    umask($umask_old);
    return 1;
}

sub command_send_v1 {
    my ($state, $file) = @_;

    $file =~ s/,(\d+)\z// ||
        return $state->adb_sync_fail("missing , in ID_SEND_V1");
    my $mode = $1;
    my $path = $state->sync_filecheck($file) // return;

    # Create containing directories
    $state->mkdirp($file) // return;

    my $type = adb_file_type_from_mode($mode);
    if ($type eq "REG") {
        unlink($path) || $! == ENOENT ||
            return $state->adb_sync_fail("couldn't unlink file: $!");
        # Owner will be able to write (mimic my android device)
        my $perms = adb_permissions_from_mode($mode) | 0200;
        # Mask because we don't want to leave world/group writable stuff
        # This all happens inside a directory that was created with mode
        # 0700 (see filesystem() in TestDrive) so there is no security issue
        # with a more permissive umask
        my $umask_old = umask(~$perms & 0777);
        open(my $fh, ">", $path);
        umask($umask_old);
        $fh || return $state->adb_sync_fail("couldn't create file: $!");
        binmode($fh);
        # What does android do if you open a symlink ?
        $state->{send_fh} = $fh;
        $state->{send_file} = $file;
        $state->{send_path} = $path;
        $state->{on_read} = \&send_read;
    } else {
        # There aren't any bad file types in the real implementation
        # There is special hadling to create symlinks
        $state->adb_sync_fail("No support for $type files");
    }
}

# Non standard adb commands for testing
sub command_internal {
    my ($state, $command) = @_;

    my $listener = $state->{listener};
    if ($command =~ m{^echo:(.*)\z}s) {
        # Fake command for response testing
        $state->adb_output(OKAY, $1);
    } elsif ($command eq "pid") {
        # Fake command: identify running process
        $state->adb_output(OKAY, $$);
    } elsif ($command eq "argv") {
        # Fake command: Show commandline
        $state->adb_output(OKAY, join("\0", @argv_old));
    } elsif (my ($serial) = $command =~ m{^device_add:(.*)\z}s) {
        # Fake command: Add device
        my $serial = $1;
        if ($listener->{devices}->get($serial)) {
            $state->adb_output(FAIL, "Already have device $serial");
        } elsif ($listener->device_add($serial, 1)) {
            # Send result
            $state->adb_output(OKAY, "Added '$serial'", 1);
        } else {
            $state->adb_output(FAIL, "Unknown device $serial");
        }
    } elsif (($serial) = $command =~ m{^device_drop:(.*)\z}s) {
        # Fake command: Drop device
        my $serial = $1;
        if (my $device = $listener->{devices}->get($serial)) {
            # Send result
            $state->adb_output(OKAY, "Dropped '$serial'", 1);
            # AFTER adb_output since this can close $state
            $device->set_offline;
            $device->drop;
        } else {
            $state->adb_output(FAIL, "No such device");
        }
    } elsif ($command =~ m{^discard:}) {
        # Fake command: identify running process
        $state->adb_output(UNCOUNTED, "discarded", 1);
    } elsif ($command =~ m{^filesystem:(.*)}) {
        my $path = $1;
        if ($state->{transport}) {
            $state->{transport}{filesystem} = $path;
            $state->adb_output(OKAY, "Set filesystem");
        } else {
            $state->adb_output(FAIL, "device offline (no transport)");
        }
    } else {
        $command = display_string($command);
        $state->adb_output(FAIL, "unknown internal command $command");
    }
}

# For host:track-devices
sub tracker {
    my ($state) = @_;

    my $listener = $state->{listener};
    my $str = $listener->{devices}->string;
    $str = sprintf("%04X", length $str) . $str;
    $state->output($str);
}

# For host:wait-for-any-device
sub waiter {
    my ($state, $device, $state_old, $state_new) = @_;
    # info("waiter  ($state->{id}):\t$device->{serial}: $state_old -> $state_new\t(Wait for $state->{wait_type} $state->{wait_mode})");

    my $disconnect = $state->{wait_mode} eq "disconnect";
    $state_new eq $state->{wait_mode} || $disconnect || return;

    if (defined $state->{wait_serial}) {
        # Wrong device
        return if $device->{serial} ne $state->{wait_serial};
        return if $state->{wait_mode} eq "disconnect" &&
            !($state_new eq "offline" || $state_new eq "");
    } else {
        return if $state->{wait_type} eq "usb" && !$device->usb;
        if ($state->{wait_mode} eq "disconnect") {
            # The device we are waiting on is a single usb device that is
            # not offline, there were no other devices.matching wait_type
            # (in *ANY* state) and the wait_type is either "usb" or "any"
            # (otherwise this waiter would not have started)
            # Since we just checked the device versus wait_type usb we know
            # the current device is a match for wait_type
            # (the $state_old eq "offline" case should be impossible)
            return unless $state_new eq "offline" || $state_new eq "" ||
                $state_old eq "" || $state_old eq "offline";
        } elsif ($state->{wait_type} eq "local" && $device->usb) {
            return;
        }
    }
    # info("waiter  ($state->{id}):\tTrigger");

    my $listener = $state->{listener};
    delete $listener->{device_events}{$state->{key}};
    $state->{on_device_event} = undef;
    $state->{on_read} = \&adb_read;
    $state->adb_output(UNCOUNTED, "");
}

package Listener;
use Scalar::Util qw(weaken);
use Storable qw(dclone);

sub DESTROY {
    # print STDERR "DESTROY(@_)\n";
    my ($listener) = @_;

    # Rescue sockets so they will get closed by the final _exit
    push @sockets, $listener->{socket} if $finish;
    --$nr_listening;
}

sub next_id {
    my ($listener) = @_;

    return sprintf("%s:%03d", $listener->{port}, ++$listener->{ids});
}

sub device_add {
    my ($listener, $serial, $may_fail) = @_;

    my $device = Device->new($listener->{devices}, $serial, $may_fail) ||
        return undef;
    $device->{state} = "";
    $device->set_offline;
    $device->set_online;
    return $device;
}

sub close {
    my $listener = shift // return;
    # Early test makes sure that the final socket closes get done by _exit
    # This makes sure that if the client sees EOF the process is actually gone
    if (keys %listeners == 1) {
        ::finish();
    } else {
        delete $listeners{$listener->{key}};
        $listener = undef;
    }
}

sub devices_init {
    my ($listener) = @_;

    my $devices = bless {
        transport_ids	=> 0,
        devices		=> {},
        listener	=> $listener,
        listening_adb	=> dclone($device_listening_adb),
    }, "Devices";
    weaken($devices->{listener});
    for my $serial (@init_devices) {
        Device->new($devices, $serial);
    }
    $listener->{devices} = $devices;
}

sub forward_drop {
    my ($listener, $serial) = @_;

    for my $from (sort keys %{$listener->{forward}}) {
        delete $listener->{forward}{$from} if $listener->{forward}{$from}[0] eq $serial;
    }
}

sub reverse_drop {
    my ($listener, $serial) = @_;

    delete $listener->{reverse}{$serial};
}

package Device;
use Carp;
use Scalar::Util qw(weaken);

sub new {
    my ($class, $devices, $serial, $may_fail) = @_;

    die "Duplicate device $serial" if $devices->{devices}{$serial};

    my %device;
    if (my ($ip, $port) = $serial =~ /^(.*):(\d+)$/a) {
        my $serial_usb = $serial_from_ip{$ip};
        if (!$serial_usb) {
            return undef if $may_fail;
            die "Unknown device ip '$ip'";
        }
        if ($devices->{listening_adb}{$serial_usb} != $port) {
            return undef if $may_fail;
            die "Device $serial_usb is not listening for adb on $serial";
        }
        %device = %{$devices{$serial_usb} ||
                        die "Assertion: Unknown serial $serial_usb"};
    } else {
        if (!$devices{$serial}) {
            return undef if $may_fail;
            die "Unknown device serial '$serial'";
        }
        %device = %{$devices{$serial}};
        $device{description} = "$device{usb} $device{description}";
    }
    $device{serial} = $serial;
    $device{transport_id} = $devices->next_id;
    $device{root} = 0;
    $device{filesystem} = undef;
    weaken($device{devices} = $devices);

    ++$nr_devices;
    return $devices->{devices}{$serial} = bless \%device, $class;
}

sub transport_id {
    return shift->{transport_id} if @_ <= 1;
    my $device = shift;
    $device->{transport_id} = shift;
}

sub packed_id {
    return pack("q", shift->transport_id);
}

sub serial {
    return shift->{serial};
}

sub serial_usb {
    return shift->{serial_usb};
}

sub state {
    return shift->{state} if @_ <= 1;

    my ($device, $state_new) = @_;

    my $state_old = $device->{state};
    return if $state_old eq $state_new;
    $device->{state} = $state_new;
    for my $state (values %{$device->listener->{device_events}}) {
        $state->{on_device_event}->($state, $device, $state_old, $state_new);
    }
}

sub set_offline {
    my ($device) = @_;

    $device->state("offline");
}

sub set_online {
    my ($device) = @_;

    $device->state("device");
}

sub reconnect {
    my ($device, $state) = @_;

    $state ||= $device->state;
    my $serial = $device->serial;
    $device->set_offline;
    $device->drop;

    my $devices = $device->{devices};
    $devices->{devices}{$serial} = $device;
    $device->{transport_id} = $devices->next_id;

    $device->{state} = "";
    $device->set_offline;
    $device->state($state);
    return $device;
}

sub root {
    return shift->{root} if @_ <= 1;

    my $device = shift;
    $device->{root} = shift ? 1 : 0;
}

# Notice that offline and online are not opposites.
# There also might be a "no device" state (I've never seen it though)
sub is_offline {
    return shift->{state} eq "offline";
}

sub is_online {
    return shift->{state} eq "device";
}

sub listener {
    return shift->{devices}->listener;
}

sub drop {
    my ($device) = @_;

    $device->{devices}->drop($device);
}

sub forward_drop {
    my ($device) = @_;

    $device->listener->forward_drop($device->serial);
}

sub reverse_drop {
    my ($device) = @_;

    $device->listener->reverse_drop($device->serial);
}

sub string {
    my ($device) = @_;

    return join "\t", @$device{qw(serial state)};
}

sub string_long {
    my ($device) = @_;

    return join("\t", @$device{qw(serial state description)}) . " transport_id:$device->{transport_id}";
}

sub features_string {
    my ($device) = @_;

    return join "," => @{$device->{features}};
}

sub usb {
    my ($device) = @_;

    return $device->{description} =~ m{(?:^| )(usb:\S+)} ? $1 : undef;
}

sub listening_adb {
    my ($device, $port) = @_;

    return $device->{devices}->listening_adb($device->serial_usb, $port);
}

sub DESTROY {
    --$nr_devices;
}

package Devices;
use Carp;
# use ADB::Client::Utils qw(info);

sub drop {
    my ($devices, $device) = @_;

    # Drop all forwards for this device.
    # Probably we should already do this if the device goes offline
    $device->forward_drop;
    $device->reverse_drop;

    my $serial = $device->serial;
    delete $devices->{devices}{$serial} || croak "Unknown serial '$serial'";

    my $listener = $devices->listener;
    for my $state (values %{$listener->{device_events}}) {
        $state->{on_device_event}->($state, $device, $device->state, "");
    }

    # Close all acepted connections that use this device as transport
    for my $state (values %{$listener->{accepted}}) {
        if ($state->{transport} == $device) {
            # print STDERR "Closing $state->{id} because transport $device->{serial} was lost\n";
            $state->adb_close_soon;
        }
    }
}

sub next_id {
    return ++shift->{transport_ids};
}

sub listener {
    return shift->{listener};
}

sub count {
    return scalar keys %{shift->{devices}};
}

sub string {
    return join "" => map $_->string . "\n" => shift->all;
}

sub string_long {
    return join "" => map $_->string_long . "\n" => shift->all;
}

sub all {
    my ($devices) = @_;

    return @{$devices->{devices}}{sort keys %{$devices->{devices}}};
}

sub get {
    my ($devices, $serial) = @_;

    return $devices->{devices}{$serial};
}

sub transport {
    my ($devices, $type, $id, $serial, $device) = @_;

    if (defined $id) {
        return grep $_->transport_id eq $id => $devices->all
    } elsif (defined $serial) {
        return $devices->get($serial) // ();
    } elsif ($type eq "any" || $type eq "") {
        return $device if $device;
        return $devices->all;
    } elsif ($type eq "usb") {
        return grep $_->usb => $devices->all;
    } elsif ($type eq "local") {
        return grep !$_->usb => $devices->all;
    } else {
        die "Invlid transort type '$type'";
    }
}

sub listening_adb {
    my ($devices, $serial_usb, $port_new) = @_;

    $devices{$serial_usb} || die "Unknown device '$serial_usb'";
    my $ip = $devices{$serial_usb}{ip};
    my $port_old = $devices->{listening_adb}{$serial_usb} //
        die "Unknown device '$serial_usb'";
    my $net = "$ip:$port_old";
    if (defined $port_new && $port_new != $port_old) {
        $devices->{listening_adb}{$serial_usb} = $port_new;

        # offline device connected to old port
        my $device = $devices->get($net);
        $device->set_offline if $device;

        # online device connected to new port
        $device = $devices->get("$ip:$port_new");
        $device->set_online if $device;

        # Reconnect the USB devce
        $device = $devices->get($serial_usb);
        $device->reconnect if $device;
    }
    return $net;
}

sub dumper {
    my ($devices, $msg) = @_;

    local $devices->{listener} = "<listener>";
    $msg ||= "Devices";
    print STDERR ::dumper($msg, $devices);
}

package main;
event_init();
unalarm();
unidle();
eval { main() };
if ($@) {
    select(STDERR);
    $| = 1;
    print $@;
    exit(255);
}
exit(0);
